// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Custom fetch to surface basic error details from Supabase in the console
// When responses are non-OK, read the body as text for logging then return a fresh Response
const debugFetch: typeof fetch = async (input, init) => {
  try {
    const res = await fetch(input as RequestInfo, init as RequestInit);
    if (!res.ok) {
      const url = typeof input === 'string' ? input : (input as Request).url;
      const ct = res.headers.get('content-type') || '';

      // Try multiple strategies to safely obtain the response body text for logging.
      // Some environments do not support clone() or body may already be consumed.
      let text: string | null = null;
      try {
        // Preferred: try clone() first (doesn't consume original body in most browsers)
        text = await res.clone().text();
      } catch (cloneErr) {
        try {
          // Fallback: attempt to read the body text directly (consumes the body)
          text = await res.text();
        } catch (readErr) {
          // If we can't read the body at all, log what we have and return the original response.
          console.error('Supabase request failed (unable to read response body for logging)', {
            url,
            status: res.status,
            statusText: res.statusText,
            type: res.type,
            contentType: ct,
            error: cloneErr || readErr,
          });
          return res;
        }
      }

      // At this point we have `text` (string). Try to parse JSON when appropriate.
      let parsedBody: any = text;
      if (ct.includes('application/json')) {
        try {
          parsedBody = JSON.parse(text || '');
        } catch (e) {
          // leave as raw text
        }
      }

      console.error('Supabase request failed', {
        url,
        status: res.status,
        statusText: res.statusText,
        type: res.type,
        contentType: ct,
        body: parsedBody,
      });

      // Recreate a fresh Response (using the captured text) so the Supabase SDK can still consume it.
      const headers = new Headers(res.headers ?? {});
      // Ensure content-type remains accurate if known
      if (text !== null && !headers.has('content-type') && ct) {
        headers.set('content-type', ct);
      }

      const fresh = new Response(text as any, {
        status: res.status,
        statusText: res.statusText,
        headers,
      });

      return fresh;
    }

    return res;
  } catch (networkError) {
    console.error('Supabase network error', networkError);
    throw networkError;
  }
};

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error('Supabase is not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY.');
}

export const supabase = createClient<Database>(
  SUPABASE_URL || '',
  SUPABASE_PUBLISHABLE_KEY || '',
  {
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
    },
    global: {
      fetch: debugFetch,
    },
  }
);

// Export createClient for re-export compatibility
export { createClient };
