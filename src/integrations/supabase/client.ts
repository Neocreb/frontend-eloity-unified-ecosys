// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Custom fetch that logs failures without interfering with downstream consumers.
// We avoid reading the response body directly; when possible we create a fresh
// Response instance containing the same bytes so later readers (like
// supabase-js internals) can safely consume the body even if an upstream
// consumer drained the original stream.
const debugFetch: typeof fetch = async (input, init) => {
  try {
    const res = await fetch(input as RequestInfo, init as RequestInit);

    // Log headers/metadata only; avoid reading body here to prevent interfering
    // with downstream consumers. If possible, create a fresh Response copy so
    // later readers can safely consume it even if upstream code already consumed
    // the original stream.
    try {
      const url = typeof input === 'string' ? input : (input as Request).url;
      const ct = res.headers.get('content-type') || '';
      const metadata = { url, status: res.status, statusText: res.statusText, type: res.type, contentType: ct };

      if ((res.status === 404 || res.status === 400) && typeof url === 'string') {
        const restMatch = url.match(/\/rest\/v1\/([a-zA-Z0-9_]+)/);
        const tableName = restMatch ? restMatch[1] : null;
        if (tableName) {
          console.warn(`Supabase REST ${res.status} for table "${tableName}": the table may not exist or is unauthorized. URL: ${url}`);
          try { console.warn('Supabase request metadata:', JSON.stringify(metadata)); } catch (_) { console.warn('Supabase request metadata (could not stringify)'); }
        }
      } else if (!res.ok) {
        console.error('Supabase request failed', metadata);
        try { console.error('Supabase request failed (stringified):', JSON.stringify(metadata)); } catch (_) { /* ignore */ }
      }
    } catch (e) {
      console.error('Supabase metadata log error', e);
    }

    // Attempt to return a fresh Response instance with the same body contents so
    // downstream consumers can read it even if the original stream was consumed.
    try {
      const buffer = await res.arrayBuffer();
      const headers = new Headers();
      res.headers.forEach((v, k) => headers.set(k, v));
      const newRes = new Response(buffer, { status: res.status, statusText: res.statusText, headers });
      return newRes as any;
    } catch (readErr) {
      // If we can't read/clone the body (it may already be consumed), fall back
      // to returning the original response. This may still surface the original
      // "body stream already read" error; in that case the upstream consumer is
      // responsible for not draining the response before Supabase.
      console.warn('debugFetch: could not clone response body, returning original response', readErr);
      return res;
    }
  } catch (networkError) {
    console.error('Supabase network error', networkError);
    throw networkError;
  }
};

let _supabase: any;
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error('Supabase is not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY.');
  // Provide a defensive stub to avoid runtime "Failed to fetch" errors when
  // code attempts to call supabase methods while the env is not set.
  const missingMsg = 'Supabase client not initialized: missing VITE_SUPABASE_URL or VITE_SUPABASE_PUBLISHABLE_KEY.';
  const thrower = () => { throw new Error(missingMsg); };
  // Minimal proxy that throws on any usage and helps callers fail fast with a clear message.
  // This prevents attempts to perform network fetches to an invalid URL (which cause the generic "Failed to fetch").
  // Consumers should handle this error or configure the environment correctly.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _supabase = new Proxy({}, {
    get() { return thrower; },
    apply() { return thrower; },
  });
} else {
  _supabase = createClient<Database>(
    SUPABASE_URL,
    SUPABASE_PUBLISHABLE_KEY,
    {
      auth: {
        storage: typeof window !== 'undefined' ? localStorage : undefined,
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
      },
      global: {
        fetch: debugFetch,
      },
    }
  );
}

export const supabase = _supabase;

// Export createClient for re-export compatibility
export { createClient };
